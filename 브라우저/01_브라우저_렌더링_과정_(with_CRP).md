### 01. 브라우저 렌더링 과정 (with CRP)

---

- 사용자가 주소창에 웹사이트 주소를 입력하고 엔터키를 누르면 해당 사이트의 화면이 표시된다. 단순하면서 당연해보이는 일이지만 주소 입력만으로 화면이 등장하기까지는 복잡한 과정들을 거쳐야 한다.
- 브라우저 렌더링 전체 과정 미리보기

  > 1.  브라우저는 HTML, CSS, JS, 이미지, 폰트 등 리소스를 서버에 요청하고, 응답으로 받아온다.
  > 2.  브라우저 렌더링 엔진은 받아온 HTML, CSS를 파싱해 DOM, CSSOM을 생성하고, 이들을 결합해 렌더 트리를 생성한다.
  > 3.  브라우저 JS 엔진은 받아온 JS를 파싱해 AST를 생성하고, 바이트코드로 변환해 실행한다.
  > 4.  렌더트리를 기반으로 HTML 요소의 레이아웃(위치, 크기)을 계산한다.
  > 5.  화면에 HTML요소를 페인팅한다

<br>

#### 1. 요청과 응답

---

> Step1. 브라우저는 HTML, CSS, JS, 이미지, 폰트 등 리소스를 서버에 요청하고, 응답으로 받아온다.

- 브라우저는 필요한 리소스(HTML, CSS, JS, 이미지, 폰트 등)를 서버에 요청하고, 응답으로 받아와야 한다.
- 브라우저의 요청 및 응답 과정은 아래와 같다.

  1. URL 입력 → 브라우저가 서버 주소(IP) 찾기 (DNS 조회)
     ```scss
         google.com → 142.250.xxx.xxx (예시)
     ```
  2. 서버와 연결 (TCP 핸드쉐이크 → TLS 핸드셰이크)
     - HTTPS의 경우
       - TCP 3-way handshake
         - 안정적인 전송
       - TLS handshake (암호화 채널 생성)
         - 암호화·보안
     - 위 과정을 통해 브라우저와 서버는 안전하게 데이터를 주고받을 준비를 마친다.
  3. HTTP 요청(Request) 보내기

     - 브라우저는 서버에 HTTP 요청을 보낸다.
       ```vbnet
        GET /index.html HTTP/1.1
        Host: www.google.com
        User-Agent: Chrome/...
        Accept: text/html
       ```
     - 대부분의 서버는 기본 문서로 index.html을 응답하도록 설정되어 있다.
       ```sql
        GET /
        위와 같이 요청해도
        GET /index.html
        과 동일한 경우가 많다.
       ```

  4. 서버가 요청을 처리하고 응답(Response) 전송

     - 서버는 브라우저 요청을 처리한 후 HTTP 응답을 돌려준다.

       ```php-template
        HTTP/1.1 200 OK
        Content-Type: text/html

        <!DOCTYPE html>
        <html>
        ...
        </html>
       ```

     - 응답의 구성:
       - 상태 코드 (200, 404, 500 …)
       - 헤더 (Content-Type, Cache-Control 등)
       - 바디(data) → HTML / JSON / 이미지 등 실제 내용

  5. 브라우저는 index.html 뿐 아니라 추가 리소스도 자동 요청

     - 브라우저는 서버에서 받은 index.html을 파싱하기 시작하고, 그 과정에서 필요한 리소스(CSS, JS, 이미지 등)를 추가로 자동 요청한다
     - 예를 들어 HTML 안에 다음이 있다면:
       ```html
       <link rel="stylesheet" href="/styles.css" />
       <script src="/main.js"></script>
       <img src="/logo.png" />
       ```
       브라우저는 다음과 같은 요청을 추가로 보낸다.
       ```
        GET /styles.css
        GET /main.js
        GET /logo.png
       ```

- 요약

1. 주소 입력 → DNS 조회
2. 서버와 연결 (TCP/TLS)
3. 브라우저가 HTTP 요청 전송
4. 서버가 index.html 등 응답 전송
5. 브라우저는 HTML 분석 중 필요한 리소스를 다시 요청

<br>

#### 2-1. HTML 파싱과 DOM 생성

---

> Step2. 브라우저 렌더링 엔진은 받아온 HTML, CSS를 파싱해 DOM, CSSOM을 생성하고, 이들을 결합해 렌더 트리를 생성한다.

- 응답으로 받아온 HTML 문서는 오직 텍스트로만 이루어져있다. 이 텍스트들이 우리의 화면에 보이기 위해서는 이 문서를 **브라우저가 이해할 수 있는 형태**로 바꾸는 작업이 필요하다. 이 형태를 바로 `DOM 구조`라고 한다.
- 서버에서 받아온 파일을 브라우저가 이해하기까지의 과정은 다음과 같다.
  1. 바이트(Bytes)
     - 서버는 브라우저에게 2진수 형태의 HTML 문서를 응답으로 준다.
  2. 문자열(Characters)
     - 문서는 \<meta\>의 charset 속성에 지정된 방식으로 문자열로 인코딩 된다.(ex. UTF-8) 서버는 이 인코딩 방식을 응답 헤더에 담아준다.
  3. 토큰(Tokens)
     - 문자열 형태의 HTML문서를 '토큰'단위로 분해한다. (문법적 의미를 갖는 코드의 최소 단위)
  4. 노드(Nodes)
     - 각 토큰을 객체로 변환해, 노드를 생성한다. (DOM을 구성하는 기본 요소)
  5. DOM(Document Ojbect Model)
     - HTML문서의 요소들의 중첩관계를 기반으로 노드들을 트리 구조로 구성한다. 이 트리를 DOM이라고 한다.
- 위와 같은 과정을 거쳐서 HTML 문서가 파싱되고, DOM 이라는 결과물을 생성하게 된다. 이는 브라우저를 위함이다. 브라우저는 자바스크립트 언어만 알아듣는데, `자바스크립트는 HTML의 태그나 속성들을 바로 다룰 수 없기 때문에 다룰 수 있는 형태인 '객체'로 바꿔주어야 한다.` 이를 통해 브라우저도 HTML 문서를 이해할 수 있게 된다.

<br>

#### 2-2. CSS파싱과 CSSOM 생성

---

- 브라우저는 HTML 파일을 파싱하다가 \<link\>, \<style\> 태그를 만나면 파싱을 잠시 멈추고 리소스 파일을 서버로 요청한다. 이 태그들은 `CSS 파일을 가져올 때 보통 사용되는데, 이렇게 가져온 CSS 파일도 HTML과 마찬가지로 파싱을 한다.`
- 서버에서 받아온 2진수 파일을 문자열로 인코딩하고, 토큰 단위로 나눈 후 노드를 생성하고, 트리를 만드는데, 이렇게 파싱해 만든 트리를 `CSSOM`이라고 한다.
- CSSOM은 CSS Object Model의 줄임말이다. 즉, CSS문서를 객체 모델로 바꾼 것이다. CSSOM을 생성하고 나면, HTML 파일은 다시 본론으로 돌아가 파싱을 멈췄던 부분부터 다시 파싱을 시작해 DOM을 마저 생성한다.
- CSSOM과 DOM의 차이점은 `CSS의 속성은 상속이 되기 때문`에, 이를 반영한다는 것이다. 예를들어, ul이 부모 요소이고, li를 자식요소로 가진다고 가정해보자.
  - 아래 코드처럼 ul는 파란색 속성을 가지고 있는데, 이 속성은 자식 요소인 li도 상속받게 된다. 따라서 li는 상속받은 color: blue와 자신이 가지고 있던 font-size 속성 두 가지를 갖게 된다.
    ```css
    ul {
      color: blue;
    }
    li {
      font-size: 10px;
    }
    ```

<br>

#### 2-3. 렌더트리 생성

---

- DOM과 CSSOM은 유사한 구조처럼 보이지만 서로 다른 속성들을 가진 독립적인 트리들이다. HTML은 문서의 구조를 담당하고, CSS는 문서의 디자인을 담당하기 떄문에 이 둘을 합치는 작업이 필요하다.
- `렌더트리`는 이름처럼 렌더링을 목적으로 만드는 트리이다. 렌더링은 브라우저가 사용자에게 보여주기 위한 화면을 그리는 과정이기 때문에, `보이지 않을 요소들은 이 트리에 포함되지 않는다.` 예를들어, DOM에서는 meta태그와 같은 정보 전달 목적의 태그나 CSSOM에서는 display: none으로 보이지 않게 설정한 요소(정확히는 노드)들은 `렌더트리에서 제외된다.`
  - visibility: hidden은 레이아웃 트리에 포함되니 주의가 필요하다.
- 렌더트리는 화면에 보여주는데 사용되지만 텍스트로 구성된 객체일 뿐이다. 실제로 사용자가 보는 페이지를 만들기 위해서는 `페인팅`이라는 작업이 필요하다. 페인팅 작업은 렌더트리의 노드들이 가지고 있는 속성들을 바탕으로 이루어지는데, 이 작업은 하단에서 자세히 알아보자.
