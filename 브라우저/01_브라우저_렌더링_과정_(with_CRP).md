### 01. 브라우저 렌더링 과정 (with CRP)

---

- 사용자가 주소창에 웹사이트 주소를 입력하고 엔터키를 누르면 해당 사이트의 화면이 표시된다. 단순하면서 당연해보이는 일이지만 주소 입력만으로 화면이 등장하기까지는 복잡한 과정들을 거쳐야 한다.
- 브라우저 렌더링 전체 과정 미리보기

  > 1.  브라우저는 HTML, CSS, JS, 이미지, 폰트 등 리소스를 서버에 요청하고, 응답으로 받아온다.
  > 2.  브라우저 렌더링 엔진은 받아온 HTML, CSS를 파싱해 DOM, CSSOM을 생성하고, 이들을 결합해 렌더 트리를 생성한다.
  > 3.  브라우저 JS 엔진은 받아온 JS를 파싱해 AST를 생성하고, 바이트코드로 변환해 실행한다.
  > 4.  렌더트리를 기반으로 HTML 요소의 레이아웃(위치, 크기)을 계산한다.
  > 5.  화면에 HTML요소를 페인팅한다

<br>

#### 1. 요청과 응답

---

> Step1. 브라우저는 HTML, CSS, JS, 이미지, 폰트 등 리소스를 서버에 요청하고, 응답으로 받아온다.

- 브라우저는 필요한 리소스(HTML, CSS, JS, 이미지, 폰트 등)를 서버에 요청하고, 응답으로 받아와야 한다.
- 브라우저의 요청 및 응답 과정은 아래와 같다.

  1. URL 입력 → 브라우저가 서버 주소(IP) 찾기 (DNS 조회)
     ```scss
         google.com → 142.250.xxx.xxx (예시)
     ```
  2. 서버와 연결 (TCP 핸드쉐이크 → TLS 핸드셰이크)
     - HTTPS의 경우
       - TCP 3-way handshake
         - 안정적인 전송
       - TLS handshake (암호화 채널 생성)
         - 암호화·보안
     - 위 과정을 통해 브라우저와 서버는 안전하게 데이터를 주고받을 준비를 마친다.
  3. HTTP 요청(Request) 보내기

     - 브라우저는 서버에 HTTP 요청을 보낸다.
       ```vbnet
        GET /index.html HTTP/1.1
        Host: www.google.com
        User-Agent: Chrome/...
        Accept: text/html
       ```
     - 대부분의 서버는 기본 문서로 index.html을 응답하도록 설정되어 있다.
       ```sql
        GET /
        위와 같이 요청해도
        GET /index.html
        과 동일한 경우가 많다.
       ```

  4. 서버가 요청을 처리하고 응답(Response) 전송

     - 서버는 브라우저 요청을 처리한 후 HTTP 응답을 돌려준다.

       ```php-template
        HTTP/1.1 200 OK
        Content-Type: text/html

        <!DOCTYPE html>
        <html>
        ...
        </html>
       ```

     - 응답의 구성:
       - 상태 코드 (200, 404, 500 …)
       - 헤더 (Content-Type, Cache-Control 등)
       - 바디(data) → HTML / JSON / 이미지 등 실제 내용

  5. 브라우저는 index.html 뿐 아니라 추가 리소스도 자동 요청

     - 브라우저는 서버에서 받은 index.html을 파싱하기 시작하고, 그 과정에서 필요한 리소스(CSS, JS, 이미지 등)를 추가로 자동 요청한다
     - 예를 들어 HTML 안에 다음이 있다면:
       ```html
       <link rel="stylesheet" href="/styles.css" />
       <script src="/main.js"></script>
       <img src="/logo.png" />
       ```
       브라우저는 다음과 같은 요청을 추가로 보낸다.
       ```
        GET /styles.css
        GET /main.js
        GET /logo.png
       ```

- 요약

1. 주소 입력 → DNS 조회
2. 서버와 연결 (TCP/TLS)
3. 브라우저가 HTTP 요청 전송
4. 서버가 index.html 등 응답 전송
5. 브라우저는 HTML 분석 중 필요한 리소스를 다시 요청

<br>

#### 2-1. HTML 파싱과 DOM 생성

---

> Step2. 브라우저 렌더링 엔진은 받아온 HTML, CSS를 파싱해 DOM, CSSOM을 생성하고, 이들을 결합해 렌더 트리를 생성한다.

- 응답으로 받아온 HTML 문서는 **그 자체로는 그냥 텍스트(문자열)** 이다. 이 텍스트가 화면에 보이기 위해서는 문서를 **브라우저 엔진이 이해할 수 있는 내부 구조**로 변환하는 과정이 필요하다. 이 구조를 바로 `DOM(Document Object Model)`이라고 한다.
- 서버에서 받아온 파일이 DOM이 되기까지의 과정은 다음과 같다.
  1. 바이트(Bytes)
     - 서버는 브라우저에게 2진수(바이트) 단위의 HTML 문서를 전송한다.
  2. 문자열(Characters) 디코딩
     - 브라우저는 응답 헤더의 Content-Type / charset(또는 \<meta charset="UTF-8" /\>) 정보를 참고해 바이트를 문자열로 디코딩한다.
       (예: UTF-8, EUC-KR 등)
  3. 토큰(Tokens) 생성
     - 문자열 형태의 HTML 문서를 문법적으로 의미 있는 최소 단위인 토큰으로 분해한다.
       (예: 시작 태그 토큰 \<div\>, 종료 태그 토큰 \</div\>, 텍스트 노드 토큰 등)
  4. 노드(Nodes)
     - 각 토큰을 기반으로 브라우저 내부에서 객체(노드)를 생성한다. 이 노드들이 DOM을 구성하는 기본 요소가 된다.
  5. DOM(Document Ojbect Model)
     - HTML 요소들의 중첩 구조(부모–자식 관계, 형제 관계)를 바탕으로 노드들을 트리 구조로 연결한다. 이렇게 만들어진 트리가 바로 DOM이다.
- 위 과정을 거쳐 HTML 문서는 파싱되고, 브라우저 내부에는 `DOM 트리`가 만들어진다.
- DOM은 단지 자바스크립트를 위한 것만이 아니라, 브라우저 렌더링 엔진이 문서를 이해하기 위한 공통 데이터 구조이며 자바스크립트에서는 document, element 객체를 통해 이 DOM에 접근하고, HTML을 동적으로 조작할 수 있다.
- HTML 파싱은 `스트리밍 방식`으로 진행되기 때문에, 문서를 모두 받은 뒤에 한 번에 파싱하는 것이 아니라 받는 동시에 위에서 아래로 조금씩 파싱된다. 이때, 중간에 \<script\> 태그(특히 defer, async 없는 경우)를 만나면 해당 스크립트를 내려받고 실행할 때까지 **HTML 파싱이 잠시 중단(block)** 될 수 있다. 그래서 \<script\> 태그의 위치와 defer/async 사용 여부가 성능에 영향을 준다.
- HTML 파서는 에러에 관대한 특성을 가지고 있어서, 태그를 조금 잘못 써도(닫는 태그 누락 등) 최대한 브라우저가 알아서 보정해 DOM을 생성하려고 한다.

<br>

#### 2-2. CSS파싱과 CSSOM 생성

---

- 브라우저는 HTML 파일을 파싱하다가 \<link\>, \<style\> 태그를 만나면 그 안에 명시된 CSS 리소스를 추가로 요청하거나, 인라인 스타일을 함께 파싱한다.
  - \<link rel="stylesheet" href="/style.css" /\> → style.css를 네트워크로 요청
  - \<style\>...\</style\> → 문서 안의 CSS를 즉시 파싱
- 이렇게 가져온 CSS도 HTML과 마찬가지로 파싱 과정을 거쳐 트리 구조로 바뀐다.
  - 바이트 → 문자열 디코딩
  - 토큰화 (선언, 선택자, 중괄호 등)
  - 노드 생성
  - 트리 구성
- 이때 생성되는 트리를 `CSSOM(CSS Object Model)`이라고 한다.
  - 이름 그대로 **CSS 문서를 객체 모델로 표현한 것**이다.
- 일반적인 설명에서 “CSS가 렌더링을 차단한다”라고 말하는 이유는 스타일 정보가 확정되기 전에는 레이아웃과 페인팅을 정확히 계산할 수 없기 때문이다. 그래서 브라우저는 필수적인 CSS 파일이 모두 로드되고 나서야 본격적으로 화면을 그린다.
- HTML 파싱 도중 CSS 리소스 요청이 일어나지만, DOM 파싱 자체가 완전히 멈춰버리는 것은 아니고(구체적인 동작은 브라우저 구현마다 다르지만), 렌더링(화면 그리기) 단계가 CSS 로딩/파싱 완료를 기다리는 것으로 이해하면 더 자연스럽다.
- CSSOM과 DOM의 차이 중 하나는, CSS의 `상속과 계산된 스타일(computed style)`이 반영된다는 점이다. 예를 들어, ul이 부모 요소이고, li가 자식 요소라고 한다면 다음과 같다.

  ```css
  ul {
    color: blue;
  }
  li {
    font-size: 10px;
  }
  ```

  - ul에 선언된 color: blue는 자식인 li까지 상속된다.
  - 결과적으로 렌더링 시점에서 li는 color: blue + font-size: 10px 두 가지 속성을 함께 갖게 된다.

<br>

#### 2-3. 렌더트리 생성

---

- DOM과 CSSOM은 구조는 비슷해 보이지만, 담고 있는 정보와 역할이 서로 다른 독립적인 트리이다.
  - DOM → 문서의 구조(어떤 요소가 어떤 자식/형제를 가지는지)
  - CSSOM → 문서에 적용될 스타일 정보(각 노드의 스타일 규칙)
- 실제로 사용자에게 화면을 그리기 위해서는 이 두 정보를 합쳐 **보여질 요소만 모은 트리**가 필요하다. 이때 생성되는 것이 `렌더 트리(Render Tree)`이다.
- 렌더 트리는 이름 그대로 렌더링을 목적으로 만들어지는 트리이기 때문에 사용자에게 보이지 않는 요소들은 포함되지 않는다. 예를 들어, DOM에서 `meta`, `head` 같은 정보 전달용 태그, CSSOM에서 `display: none` 이 적용된 요소(노드) 등은 렌더 트리에서 제외된다.
- 반대로 `visibility: hidden`은 보이지 않지만 레이아웃 상 공간을 차지하기 때문에 렌더 트리에 포함된다. (레이아웃/페인팅에는 영향을 준다는 점에 주의)
- 렌더 트리는 아직까지는 텍스트 기반의 객체 구조일 뿐이고, 실제 픽셀로 그려진 화면은 아니다. 다음 단계에서 브라우저는 **렌더 트리를 바탕으로 레이아웃(각 노드의 위치/크기 계산)**을 수행하고, 이후 **페인팅(Paint)** 단계에서 색, 테두리, 그림자 등을 실제 픽셀로 칠해 사용자가 보게 되는 페이지를 만든다.

<br>

#### 3. Javascript 파싱

---

> Step3. 브라우저 JS 엔진은 받아온 JS를 파싱해 AST를 생성하고, 바이트 코드로 변환해 실행한다.

- 렌더링 엔진은 HTML 파일을 한줄씩 파싱하며 DOM을 생성하다가 Javascript 코드를 불러오는 script 태그를 만날 때도 파싱을 잠시 멈춘다. 그리고나서 src 속성에 설정된 파일을 서버에 요청해 받아온다. 이렇게 받아온 js 파일도 마찬가지로 파싱을 해야하는데, 이 파싱은 브라우저 렌더링 엔진이 직접하지 않고, `Javascript 엔진이 담당하게 된다.` 이때 **렌더링 엔진은 JS 엔진에게 제어권을 아예 넘겨주기 때문에, HTML 파싱을 멈췄다가 JS파싱이 완료되면 다시 제어권을 돌려받아 파싱을 진행한다.**
- JS 엔진은 Javascript 파일의 코드를 파싱해서 컴퓨터가 이해할 수 있는 기계어로 변환하고 실행한다. 조금 더 구체적으로 살펴보면, 먼저 단순한 텍스트 문자열인 코드를 토큰 단위로 분해한다. 이렇게 분해된 토큰에 문법적인 의미와 구조가 더해져, `AST(추상 구문 트리)`라는 트리가 완성된다. 구체적인 속성은 다르지만, 이전에 봤던 과정들과 유사하다.
- 코드를 해석해서 만든 AST라는 트리를 실제로 실행하는 역할은 인터프리터가 담당한다. 인터프리터가 이해할 수 있도록 하기 위해서는 `AST트리를 바이트 코드라는 중간 수준의 코드로 변환해야 한다.` 이 변환은 바이트코드 생성기가 담당해준다.
- JS 파일 → (파싱) → 토큰 단위로 분해 → AST 트리 생성 → 컴파일 → 바이트 코드
