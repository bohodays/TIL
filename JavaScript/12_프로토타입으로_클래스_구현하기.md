### 12. 프로토타입으로 클래스 구현하기

<br>

#### 1. 프로토타입으로 클래스 구현하기 (ES5 방식)

---

- 생성자 함수 정의

  ```javascript
  function Person(name, age) {
    this.name = name;
    this.age = age;
  }
  ```

- 메서드를 프로토타입에 정의

  ```javascript
  Person.prototype.sayHello = function () {
    console.log(`Hello, I'm ${this.name} and I'm ${this.age} years old.`);
  };
  ```

- 객체 생성

  ```javascript
  const p1 = new Person("Jungwon", 29);
  p1.sayHello(); // Hello, I'm JungWon and I'm 29 years old.
  ```

<br>

#### 2. 상속 구현하기 (프로토타입 상속)

---

- 부모 클래스

  ```javascript
  function Animal(name) {
    this.name = name;
  }

  Animal.prototype.speak = function () {
    console.log(`${this.name} makes a sound.`);
  };
  ```

- 자식 클래스

  ```javascript
  function Dog(name, breed) {
    Animal.call(this, name); // 부모 생성자 호출
    this.breed = breed;
  }

  // 프로토타입 상속
  Dog.prototype = Object.create(Animal.prototype);
  Dog.prototype.constructor = Dog; // constructor 복원

  Dog.prototype.speak = function () {
    console.log(`${this.name} barks.`);
  };
  ```

  - Animal.call(this, name)
    - `call`은 함수(여기서는 Animal 생성자)를 강제로 실행하면서 this를 바인딩하는 함수
    - Dog 안에서 Animal을 대신 실행시키면서 Animal 내부의 this를 Dog 인스턴스로 바꾸는 것
  - Dog.prototype = Object.create(Animal.prototype)
    - 전달한 객체(proto)를 부모로 갖는 "새로운 객체"를 생성
    - 이를 통해 Dog.prototype이 Animal.prototype을 상속받아 Dog 인스턴스도 Animal 메서드를 사용할 수 있게 됨
  - Dog.prototype.constructor = Dog
    - Dog.prototype = Object.create(Animal.prototype) 때문에 Dog.prototype의 constructor 값이 원래 Animal로 바뀌어버리기 때문에 다시 돌려놓는 것

- 사용

  ```javascript
  const myDog = new Dog("Milo", "Shiba");
  myDog.speak(); // Milo barks.
  ```

<br>

#### 3. ES6 class로 비교

---

- class 문법은 프로토타입 기반 문법을 더 쉽게 쓰도록 만든 문법 설탕(syntactic sugar)이다

  ```javascript
  class Person {
    constructor(name, age) {
      this.name = name;
      this.age = age;
    }

    sayHello() {
      console.log(`Hello, I'm ${this.name} and I'm ${this.age} years old.`);
    }
  }
  ```
